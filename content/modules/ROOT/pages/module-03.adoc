= Module 3: Deploying and Verifying the Appliance
:page-nav-title: Deploy & Verify Appliance
:icons: font
:source-highlighter: rouge
:experimental:

[#boot_vm]
== 3.1 Hands-On: Creating and Booting the Test VM
Now that your ISO is built, it’s time to launch the appliance inside a virtual machine.

In this environment, VM creation is automated using two helper scripts:

* **create-ks.sh** – generates the Kickstart file used for automated installation  
* **create-vm.sh** – creates the KVM virtual machine and attaches the ISO  

Let’s walk through both so you understand what’s happening behind the scenes.

=== View the Kickstart generator (`create-ks.sh`)
This script prepares the Kickstart config that defines the automated installation process for the VM.

. View the Kickstart creation script:
+
[source,sh,role=execute]
----
cat create-ks.sh
----
+
[%collapsible]
====
.Output of `create-ks.sh`
[source,bash]
----
#!/bin/bash
cat <<EOF > kickstart.ks
text
zerombr
clearpart --all --initlabel
ignoredisk --only-use=vda
autopart --type=plain --nohome
reboot

# Set root password
rootpw --plaintext redhat

# Set timezone
timezone UTC --isUtc

# Use the installation source inside the ISO
cdrom

# Do not run the first-boot setup
firstboot --disable

%post
echo "Kickstart installation completed"
%end
EOF
----
====

[NOTE]
====
Kickstart automates the OS installation so the VM can boot straight into your Image Mode appliance with zero manual clicks.
====

=== View the VM creation script (`create-vm.sh`)
This script uses KVM + virt-install to spin up a VM using the ISO you generated.

. View the VM creation script:
+
[source,sh,role=execute]
----
cat create-vm.sh
----
+
[%collapsible]
====
.Output of `create-vm.sh`
[source,bash]
----
#!/bin/bash

ISO="_build/microshift-v1.iso"
VM_NAME="microshift-bootc"
KS_FILE="kickstart.ks"

qemu-img create -f qcow2 ${VM_NAME}.qcow2 40G

virt-install \
    --name ${VM_NAME} \
    --ram 4096 \
    --vcpus 2 \
    --disk path=${VM_NAME}.qcow2,size=40 \
    --cdrom ${ISO} \
    --os-variant rhel9.3 \
    --network network=default \
    --graphics none \
    --initrd-inject=${KS_FILE} \
    --extra-args="inst.ks=file:/kickstart.ks console=ttyS0"
----
====

[NOTE]
====
This script creates a VM, attaches your self-contained ISO, injects the Kickstart file, and starts the automated installation.
====

=== Create and boot the VM

. Generate the Kickstart file:
+
[source,sh,role=execute]
----
bash create-ks.sh
----

. Create and start the VM:
+
[source,sh,role=execute]
----
bash create-vm.sh
----

Once the VM begins booting, connect to the console if needed:

[source,sh,role=execute]
----
virsh console microshift-bootc
----

You should now see the appliance boot into Image Mode.

---

== 3.2 Verifying the Appliance After Boot
Once logged in, verify that the system is running correctly.

=== Check bootc system status
. Confirm the system is running the v1 deployment:
+
[source,sh,role=execute]
----
sudo bootc status
----

=== Check MicroShift
. Verify the node is ready:
+
[source,sh,role=execute]
----
oc get nodes
----

=== Check application pods
. WordPress and MySQL should be running:
+
[source,sh,role=execute]
----
oc get pods -A
----

=== Check embedded container images
. Ensure the images came from the ISO (not pulled from the network):
+
[source,sh,role=execute]
----
sudo crictl images
----

[NOTE]
====
This confirms your appliance is fully **air-gapped** and relying on the embedded images you packaged inside the ISO.
====

---

[#manifests]
== 3.3 Exploring the WordPress Manifests

=== View the Kustomization file
. Review how Kubernetes manifests are organized:
+
[source,sh,role=execute]
----
cat manifests/kustomization.yaml
----
+
[%collapsible]
====
[source,yaml]
----
resources:
  - wordpress.yaml
  - mysql.yaml
namespace: wordpress
----
====

=== View the WordPress deployment
. Inspect the WordPress deployment:
+
[source,sh,role=execute]
----
cat manifests/wordpress.yaml
----
+
[%collapsible]
====
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 1
  template:
    spec:
      containers:
        - name: wordpress
          image: docker.io/library/wordpress:6.2.1-apache
          ports:
            - containerPort: 80
          env:
            - name: WORDPRESS_DB_HOST
              value: mysql
----
====

[NOTE]
====
MicroShift runs this container using the **embedded image**, not pulling from Docker Hub.
====

---

== 3.4 Optional Troubleshooting

. Check MicroShift logs:
+
[source,sh,role=execute]
----
sudo journalctl -u microshift -f
----

. Confirm the root filesystem is Image Mode:
+
[source,sh,role=execute]
----
cat /etc/os-release
----

---

Next: xref:module-04.adoc[Module 4: Performing an Atomic Update (v1 → v2)]
