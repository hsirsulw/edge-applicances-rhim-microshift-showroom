= Module 2: Building the Self-Contained Appliance 
:page-nav-title: Build the Self-Contained Appliance
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* Understand the structure of a bootc Containerfile and how it extends a base RHEL image
* Explain why EUS (Extended Update Support) images are used for appliances
* Explain why `redhat.repo` (or equivalent) is embedded in the base image
* Explain physically-bound images and how container images are embedded immutably
* Understand why embedded images are placed under `/usr/lib` rather than `/var`
* Build a base RHEL image with MicroShift using Podman
* Build a self-contained appliance image with embedded applications
* Generate a bootable ISO from a container image using the bootc-image-builder

[#containerfile]
== 2.1 Anatomy of a bootc Appliance Containerfile
A `Containerfile` is the recipe for your appliance. It defines:

* The base OS (RHEL bootc base)
* MicroShift components and required RPMs
* System configuration, firewall, and hardening
* Embedded manifests (Quadlets) and application images
* Scripts or units to import embedded images at runtime

=== Why use EUS (Extended Update Support)?
We choose **EUS** images for appliances because they provide:
* Long lifecycle stability (fewer, predictable changes)
* A predictable minor release stream (helpful for validated appliances)
* A better platform match for long-running edge/industrial deployments

Appliances typically prefer stability and predictability over the fastest-moving release.

=== Why embed `redhat.repo` (or repo metadata) into the image?
`bootc-image-builder` and container-based builds use `dnf` within the image build. To ensure `dnf` can resolve packages during build, the base image must contain repo metadata (for example `/etc/yum.repos.d/redhat.repo`). Embedding the repo file inside the base ensures that:

* Builds are reproducible (the same repos used each time).
* `dnf` can perform package installs during the container build step.
* The image builder has the correct subscription/repo context.

. View the `Containerfile` for the base image:
+
[source,sh,role=execute]
----
cat Containerfile.base
----
+
[%collapsible]
====
.Output of `$cat Containerfile.base`
[source,dockerfile]
----
FROM registry.redhat.io/rhel9-eus/rhel-9.6-bootc:9.6
ARG VERSION_ID="9.6"

## Needed as bootc-image-builder requires a repo file to be present in the base image.
ADD redhat.repo /etc/yum.repos.d/redhat.repo
# workaround for this lab, as we didn't managed to push signatures for lvm operator and ubi images from registry.redhat.io 
ADD policy.json /etc/containers/policy.json

RUN dnf install -y --releasever="${VERSION_ID}" firewalld jq microshift microshift-release-info cockpit openscap-utils scap-security-guide && \
    systemctl enable microshift && \
    dnf clean all

# Create a default 'redhat' user with the specified password.
# Add it to the 'wheel' group to allow for running sudo commands.
ARG USER_PASSWD
RUN if [ -z "${USER_PASSWD}" ] ; then \
        echo USER_PASSWD is a mandatory build argument && exit 1 ; \
    fi

RUN useradd -m -d /var/home/redhat -G wheel redhat && \
    echo "redhat:${USER_PASSWD}" | chpasswd

# Mandatory firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=22/tcp && \
    firewall-offline-cmd --zone=trusted --add-source=10.42.0.0/16 && \
    firewall-offline-cmd --zone=trusted --add-source=169.254.169.1 && \
    firewall-offline-cmd --zone=trusted --add-source=fd01::/48
    # Application-specific firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=80/tcp && \
    firewall-offline-cmd --zone=public --add-port=443/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/udp

# Create a systemd unit to recursively make the root filesystem subtree
# shared as required by OVN images
RUN cat > /etc/systemd/system/microshift-make-rshared.service <<'EOF'
[Unit]
Description=Make root filesystem shared
Before=microshift.service
ConditionVirtualization=container
[Service]
Type=oneshot
ExecStart=/usr/bin/mount --make-rshared /
[Install]
WantedBy=multi-user.target
EOF

RUN systemctl enable microshift-make-rshared.service

COPY wordpress /usr/lib/microshift/manifests.d/wordpress
----
====

This Containerfile extends the RHEL EUS bootc base image, installs MicroShift, configures firewall rules, and places manifests for MicroShift.

[NOTE]
====
You don’t need to edit `Containerfile.base` for this lab — we show it so you understand what’s being installed into the appliance.
====

[#physically_bound]
== 2.2 Creating “Physically-Bound” Images
A **physically-bound** image contains everything needed to run: the OS, MicroShift, application container images, and any Quadlets/manifests. This enables **true offline operation**.

Benefits:
* Boot and run applications without any internet access
* MicroShift can start and immediately use local images
* Deterministic appliances that match exactly what you validated

=== The immutability reason: `/usr` vs `/var`
Under Image Mode the root filesystem is treated as read-only at runtime. Key points:

* `/usr` — written during the build process, becomes part of the image and is versioned with the OS.
* `/var` — runtime data store; mutable and not intended to be the place for versioned, build-time assets.

Storing embedded images under `/usr/lib/...` makes them part of the immutable image and ensures:
* Images are versioned together with the OS image
* They are upgrade-safe and roll back with the OS
* They cannot be accidentally mutated at runtime

If we stored them in `/var`, they would not be tied to the OS image lifecycle and could drift.

=== How physical embedding works (concept + commands)
We embed images using `skopeo` and the `dir:` transport during the **build**.

*Embed into a directory inside the image (build time):*

[source,bash]
----
RUN skopeo copy --preserve-digests docker://registry.example.com/my-app:1.0 \
    dir:/usr/lib/containers-image-cache/my-app-1.0
----

This creates a directory that contains the image content and preserves digests so references by SHA still work.

*At runtime (first boot or ExecStartPre), import into Podman’s mutable store:*

[source,bash]
----
/usr/bin/skopeo copy --preserve-digests \
    dir:/usr/lib/containers-image-cache/my-app-1.0 \
    containers-storage:registry.example.com/my-app@sha256:<digest>
----

This loads the embedded data into the Podman storage so MicroShift (or kubelet/container runtimes) can reference the image by name or digest.

=== Why `dir:` transport?
* `dir:` allows bundling multiple images under one directory.
* It preserves image digests (crucial for referencing by SHA).
* It’s file-system friendly and portable within the ISO.

=== Why not use a secondary image store?
A secondary store is not replaced during an OS upgrade. Embedded images *change with each OS image* and must live inside that OS image to be versioned and rolled back together. That’s why we place them under `/usr/lib`.

=== Helper scripts (what they do)
This repo includes two helper scripts you’ll see and can inspect:

* `embed_image.sh` — used during the Containerfile build to `skopeo copy` an image into the `/usr/lib/...` dir.  
  - Usage: `embed_image.sh <image-reference> [--all] [--authfile ...]`  
  - If referencing a manifest list by digest, use `--all` so `skopeo` copies the whole manifest list and ALL variant images.

* `copy_embedded_images.sh` — invoked at boot (via a systemd ExecStartPre) to copy all embedded `dir:` images into the Podman container store (containers-storage), making them available to MicroShift.

Upstream example / reference for patterns:
link:https://gitlab.com/fedora/bootc/examples/-/tree/main/physically-bound-images[physically-bound-images examples].

. View the `Containerfile` for the 4.19 appliance (embedding step):
+
[source,sh,role=execute]
----
cat Containerfile.4.19
----
+
[%collapsible]
====
.Output of `$cat Containerfile.4.19`
[source,dockerfile]
----
FROM localhost/microshift-bootc:base

ARG USHIFT_BASE_IMAGE_NAME
ARG USHIFT_BASE_IMAGE_TAG

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# use to embed application images
COPY ./embed_image.sh /usr/bin/
COPY ./copy_embedded_images.sh /usr/bin/

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# Pull the container images into /usr/lib/containers/storage:
# - Each image goes into a separate sub-directory
# - Sub-directories are named after the image reference string SHA
# - An image list file maps image references to their name SHA
# First for MicroShift payload
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json \
    images="$(jq -r ".images[]" /usr/share/microshift/release/release-"$(uname -m)".json)" ; \
    mkdir -p "${IMAGE_STORAGE_DIR}" ; \
    for img in ${images} ; do \
       /usr/bin/embed_image.sh ${img} --authfile /run/secrets/pull-secret.json ; \
     done 
# Then for Applications
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json <<PULL
    /usr/bin/embed_image.sh docker.io/library/wordpress:6.2.1-apache
    /usr/bin/embed_image.sh docker.io/library/mysql:8.0
PULL

# 

RUN mkdir -p /etc/systemd/system/microshift.service.d
RUN cat > /etc/systemd/system/microshift.service.d/microshift-copy-images.conf <<EOF
[Service]
ExecStartPre=/bin/bash /usr/bin/copy_embedded_images.sh
EOF
----
====

[#build]
== 2.3 Hands-On: Build the Base and 4.19 Images
Now you’ll run the build scripts that assemble the appliance. We suggest you **inspect** (cat) each script first, then run the build so you understand what it does.

. (Optional) View the build script for the base image:
+
[source,sh,role=execute]
----
cat build-base.sh
----
+
[%collapsible]
====
.Build script: `build-base.sh` (abridged)
[source,bash]
----
#!/bin/bash
USER_PASSWD=redhat02
IMAGE_NAME=microshift-bootc:base

dnf config-manager \
        --set-enabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
dnf config-manager --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms --set-disabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms
cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
cp /etc/containers/policy.json /home/lab-user/bootc-embeeded-containers
# Run podman build as root to allow for :z relabeling
#
# Mount the host subscription data
#
# In this lab there is no need for --authfile / pullsecret as we are pulling from a disconnected unsecure registry
sudo podman build -t ${IMAGE_NAME} \
    --build-arg USER_PASSWD=${USER_PASSWD} \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    -f Containerfile.base
----
====

. Build the base image (~5 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build-base.sh 2>&1 | tee build-base.log
----

. (Optional) View the build script:
+
[source,sh,role=execute]
----
cat build.sh
----
+
[%collapsible]
====
.Build script: `build.sh` (abridged)
[source,bash]
----
#!/bin/bash
set -e

REGISTRY_URL=quay.io
TAG=$1

if [ -z "$TAG" ]; then
    echo "Error: a tag must be provided."
    echo "Usage: $0 <tag>"
    exit 1
fi

# Set IMAGE_NAME and BASE_IMAGE_NAME based on TAG (case-insensitive)
TAG_LOWER=$(echo "$TAG" | tr '[:upper:]' '[:lower:]')
case "$TAG_LOWER" in
    4.19)
        IMAGE_NAME=microshift-bootc-embeeded
        BASE_IMAGE_NAME=microshift-bootc:base
        ;;
    4.20)
        IMAGE_NAME=microshift-bootc-embeeded
        BASE_IMAGE_NAME=microshift-bootc:4.19
        ;;
    *)
        echo "Error: TAG must be either 4.19 or 4.20"
        exit 1
        ;;
esac

#REGISTRY_IMG="rhn_support_arolivei/${IMAGE_NAME}"

# For 4.20, configure dnf repositories
if [ "$TAG_LOWER" = "4.20" ]; then
    echo "#### Configuring dnf repositories for 4.20"
    sudo dnf config-manager \
        --set-enabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
    sudo dnf config-manager \
        --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms \
        --set-disabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms
    cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
fi

echo "#### Building a new bootc image with MicroShift and application Container images embeeded to it"
sudo podman build -t "${IMAGE_NAME}:${TAG}" \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    --volume /etc/containers/registries.conf.d/99-mirrors.conf:/etc/containers/registries.conf.d/99-mirrors.conf:ro,z \
    --volume /etc/containers/policy.json:/etc/containers/policy.json:ro,z \
    --build-arg USHIFT_BASE_IMAGE_NAME="${BASE_IMAGE_NAME}" \
    --build-arg USHIFT_BASE_IMAGE_TAG=${TAG} \
    -f Containerfile.${TAG}

#echo "#### pushing bootc image to a registry"
#podman push "localhost/${IMAGE_NAME}:${TAG}" "${REGISTRY_URL}/${REGISTRY_IMG}:${TAG}"

# Only create ISO for 4.19
if [ "$TAG_LOWER" = "4.19" ]; then
    sudo mkdir -p /var/tmp/bootc-images
    echo "#### creating ISO from bootc image"
    sudo podman run --rm -it --privileged --security-opt label=type:unconfined_t \
       -v /var/lib/containers/storage:/var/lib/containers/storage \
       -v /var/tmp/bootc-images:/output \
       --volume /etc/rhsm:/etc/rhsm:ro \
       --volume /etc/pki/entitlement:/etc/pki/entitlement:ro \
        registry.redhat.io/rhel9/bootc-image-builder:latest \
        --progress=verbose --local --type iso localhost/${IMAGE_NAME}:${TAG}

    cp -v /var/tmp/bootc-images/bootiso/install.iso microshift-bootc-embeeded-4.19.iso
fi
----
====

. Build the 4.19 appliance image (~10–15 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build.sh 4.19 2>&1 | tee build-4.19.log
----

When the build completes, the ISO will appear under `_build/` or `/var/tmp/bootc-images/`.

== Validation checkpoint: Verify build success
Before proceeding, verify that both images were built successfully:

. Check that the base image exists:
+
[source,sh,role=execute]
----
sudo podman images | grep microshift-bootc:base
----

. Verify the 4.19 appliance image exists:
+
[source,sh,role=execute]
----
sudo podman images | grep microshift-bootc-embeeded:4.19
----

. Confirm the ISO file was created:
+
[source,sh,role=execute]
----
ls -lh /var/tmp/bootc-images/bootiso/*.iso || ls -lh _build/*.iso
----

[IMPORTANT]
====
**Expected results:**

* Base image `localhost/microshift-bootc:base` should be present
* Appliance image `localhost/microshift-bootc-embeeded:4.19` should be present
* ISO file `microshift-bootc-embeeded-4.19.iso` should exist in `/var/tmp/bootc-images/bootiso/` or `_build/`
* ISO file size will likely be several GB (it contains embedded container images)
====

== 2.4 What happens next
Once installed on the target VM:

* Embedded images are available *before* MicroShift starts
* The systemd ExecStartPre runs `copy_embedded_images.sh` to populate the container store
* MicroShift launches workloads immediately — no external registry needed

This pattern ensures predictable, repeatable, and offline-friendly deployments.

Next: xref:module-03.adoc[Module 3: Booting and Verifying the Appliance]
