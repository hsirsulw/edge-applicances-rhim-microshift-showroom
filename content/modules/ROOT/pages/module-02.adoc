= Module 2: Building Self-Contained Appliances
:page-nav-title: Build the Self-Contained Appliance
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* [x] Read and explain a bootc Containerfile
* [x] Understand why EUS (Extended Update Support) matters for long-lived appliances
* [x] Explain why repo metadata (`redhat.repo`) must be embedded
* [x] Define physically-bound images and why they matter for edge
* [x] Explain why embedded images live under `/usr` instead of `/var`
* [x] Build a MicroShift-enabled base image
* [x] Build a self-contained appliance with embedded workloads
* [x] Generate a bootable ISO using `bootc-image-builder`

[#know_section]
[#containerfile]
== 2.1 Know: Building Self-Contained Appliances

=== The Business Challenge
ManufacturingCo needs to deploy the same appliance to 50 factory sites — including locations with **intermittent or no network**.

[cols="1,2a", options="header"]
|===
| Traditional Method Pain Points | Image Mode Solution
| Pulling application images at runtime | **Physically-bound images:** Apps are inside the OS.
| Constant registry access required | **True offline operation:** No registry dependency.
| Manual package installs and config steps | **Deterministic deployments:** Every image is identical.
| Multi-stage deployment complexity | **Single artifact delivery:** One ISO deploys the full system.
|===

=== How Containerfiles Solve This Problem
The `Containerfile` is the **Source of Truth** for the entire appliance. It transitions the workflow from fragile manual steps to a predictable automated pipeline.

[cols="1a,1a", options="header"]
|===
| ❌ Legacy Workflow | ✅ Containerfile Workflow
| **Build → Install → Configure** | **Define → Build → Ship → Deploy**
| Multi-step, manual, and prone to "drift" between sites. | Entire stack is unified in one version-controlled file.
|===



**What the Containerfile Defines:**

* **Base OS:** The specific RHEL version (EUS).
* **MicroShift:** The core orchestration and required packages.
* **System Config:** Hardened firewall and security settings.
* **Workloads:** Quadlets, manifests, and the logic to embed application images.

=== Why We Use EUS (Extended Update Support)
EUS is chosen because edge deployments value stability over speed:

* **Lifecycle Sync:** Hardened compatibility within the Red Hat Device Edge link:https://docs.redhat.com/en/documentation/red_hat_device_edge/4/html/overview/device-edge-overview#device-edge-compatibility_device-edge-overview[matrix^].
* **Extended Support:** Up to 48 months of stability when paired with link:https://access.redhat.com/support/policy/updates/openshift#eust3[OpenShift/MicroShift EUS Term 3^].
* **Security without Friction:** Critical patches without minor version jumps.

=== View the Base Containerfile

. View the base Containerfile:
+
[source,sh,role=execute]
----
cat Containerfile.base
----
+
[%collapsible]
====
.Output of `$cat Containerfile.base`
[source,dockerfile]
----
FROM registry.redhat.io/rhel9-eus/rhel-9.6-bootc:9.6
ARG VERSION_ID="9.6"

## Needed as bootc-image-builder requires a repo file to be present in the base image.
ADD redhat.repo /etc/yum.repos.d/redhat.repo

RUN dnf install -y --releasever="${VERSION_ID}" firewalld jq microshift microshift-release-info cockpit openscap-utils scap-security-guide && \
    systemctl enable microshift && \
    dnf clean all

# Create a default 'redhat' user with the specified password.
ARG USER_PASSWD
RUN if [ -z "${USER_PASSWD}" ] ; then \
        echo USER_PASSWD is a mandatory build argument && exit 1 ; \
    fi

RUN useradd -m -d /var/home/redhat -G wheel redhat && \
    echo "redhat:${USER_PASSWD}" | chpasswd

# Mandatory firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=22/tcp && \
    firewall-offline-cmd --zone=trusted --add-source=10.42.0.0/16 && \
    firewall-offline-cmd --zone=trusted --add-source=169.254.169.1 && \
    firewall-offline-cmd --zone=trusted --add-source=fd01::/48

# Application-specific firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=80/tcp && \
    firewall-offline-cmd --zone=public --add-port=443/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/udp

# Systemd unit to ensure root filesystem is shared (required by OVN)
RUN cat > /etc/systemd/system/microshift-make-rshared.service <<'EOF'
[Unit]
Description=Make root filesystem shared
Before=microshift.service
ConditionVirtualization=container
[Service]
Type=oneshot
ExecStart=/usr/bin/mount --make-rshared /
[Install]
WantedBy=multi-user.target
EOF

RUN systemctl enable microshift-make-rshared.service
COPY wordpress /usr/lib/microshift/manifests.d/wordpress

## Apply kernel tuning for CIS hardening compliance
RUN cat > /etc/sysctl.d/99-cis-hardening.conf <<'EOF'
# IPv6 Settings
net.ipv6.conf.all.accept_ra = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_ra = 0
net.ipv6.conf.default.accept_redirects = 0
# IPv4 Settings
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.log_martians = 1
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.ip_forward = 0
# Ptrace Scope
kernel.yama.ptrace_scope = 1
EOF
RUN echo "AllowUsers redhat" >> /etc/ssh/sshd_config
# Run scan and hardening
RUN oscap-im --profile xccdf_org.ssgproject.content_profile_cis /usr/share/xml/scap/ssg/content/ssg-rhel9-ds.xml
----
====

[NOTE]
====
You do **not** need to modify `Containerfile.base` in this lab — it is provided so you understand what goes into your base appliance.
====

[#physically_bound]
== 2.2 Know: Physically-Bound Images for Disconnected Operations

=== Why `/usr` — Not `/var`?
[cols="1,2a", options="header"]
|===
| Directory | Strategy in Image Mode
| `/usr` | **Immutable:** Versioned with the OS. Apps here upgrade/rollback with the kernel.
| `/var` | **Mutable:** Runtime storage. Data here persists across OS updates.
|===



=== How Physical Embedding Works

The goal of physical embedding is to ensure MicroShift can run workloads without a registry.

* **Build time:** Use `skopeo` to copy container images into the immutable `/usr/lib` directory.
* **Runtime:** Import these images into the Podman/CRI-O store automatically during boot.

**Helper Scripts Provided:**

* `embed_image.sh`: Pulls specified container images and their digests into the OS image during the build process.

[source,bash]
----
RUN skopeo copy --preserve-digests docker://${image} \
    dir:/usr/lib/containers/storage/${sha}
----

* `copy_embedded_images.sh`: Triggered at boot, this script populates the runtime container store from the immutable `/usr/lib` cache, making images "already present" for MicroShift.

[source,bash]
----
/usr/bin/skopeo copy --preserve-digests \
  dir:/usr/lib/containers/storage/${sha} \
  containers-storage:${image}
----

Upstream reference patterns: link:https://gitlab.com/fedora/bootc/examples/-/tree/main/physically-bound-images[Fedora examples^].

. View the `Containerfile` for the 4.19 appliance:
+
[source,sh,role=execute]
----
cat Containerfile.4.19
----
+
[%collapsible]
====
.Output of `$cat Containerfile.4.19`
[source,dockerfile]
----
FROM localhost/microshift-bootc:base

ARG USHIFT_BASE_IMAGE_NAME
ARG USHIFT_BASE_IMAGE_TAG

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# use to embed application images
COPY ./embed_image.sh /usr/bin/
COPY ./copy_embedded_images.sh /usr/bin/

# Pull images into /usr/lib/containers/storage
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json \
    images="$(jq -r ".images[]" /usr/share/microshift/release/release-"$(uname -m)".json)" ; \
    mkdir -p "${IMAGE_STORAGE_DIR}" ; \
    for img in ${images} ; do \
       /usr/bin/embed_image.sh ${img} --authfile /run/secrets/pull-secret.json ; \
     done 

# Embed Applications
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json <<PULL
    /usr/bin/embed_image.sh docker.io/library/wordpress:6.2.1-apache
    /usr/bin/embed_image.sh docker.io/library/mysql:8.0
PULL

RUN mkdir -p /etc/systemd/system/microshift.service.d
RUN cat > /etc/systemd/system/microshift.service.d/microshift-copy-images.conf <<EOF
[Service]
ExecStartPre=/bin/bash /usr/bin/copy_embedded_images.sh
EOF
----
====

[#show_section]
== 2.3 Show: Build the Base Image
Building this consistent foundation solves **configuration drift**. 

. (Optional) View the build script:
+
[source,sh,role=execute]
----
cat build-base.sh
----
+
[%collapsible]
====
.Build script: `build-base.sh` (abridged)
[source,bash]
----
#!/bin/bash
USER_PASSWD=redhat02
IMAGE_NAME=microshift-bootc:base

dnf config-manager \
        --set-enabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
dnf config-manager --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms --set-disabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms
cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers

sudo podman build -t ${IMAGE_NAME} \
    --build-arg USER_PASSWD=${USER_PASSWD} \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    -f Containerfile.base
----
====

. Build the base image (~5 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build-base.sh 2>&1 | tee build-base.log
----

[#build_appliance]
== 2.4 Show: Build the Self-Contained Appliance (4.19)
We now embed WordPress and MySQL to solve the **disconnected operations challenge**.

. (Optional) View the build script:
+
[source,sh,role=execute]
----
cat build.sh
----
+
[%collapsible]
====
.Build script: `build.sh` (abridged)
[source,bash]
----
#!/bin/bash
set -e
TAG=$1
TAG_LOWER=$(echo "$TAG" | tr '[:upper:]' '[:lower:]')
IMAGE_NAME=microshift-bootc-embeeded
BASE_IMAGE_NAME=microshift-bootc:base

sudo podman build -t "${IMAGE_NAME}:${TAG}" \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    --build-arg USHIFT_BASE_IMAGE_NAME="${BASE_IMAGE_NAME}" \
    --build-arg USHIFT_BASE_IMAGE_TAG=${TAG} \
    -f Containerfile.${TAG}

if [ "$TAG_LOWER" = "4.19" ]; then
    sudo mkdir -p /var/tmp/bootc-images
    sudo podman run --rm -it --privileged --security-opt label=type:unconfined_t \
       -v /var/lib/containers/storage:/var/lib/containers/storage \
       -v /var/tmp/bootc-images:/output \
       --volume /etc/rhsm:/etc/rhsm:ro \
       --volume /etc/pki/entitlement:/etc/pki/entitlement:ro \
        registry.redhat.io/rhel9/bootc-image-builder:latest \
        --progress=verbose --local --type iso localhost/${IMAGE_NAME}:${TAG}
    cp -v /var/tmp/bootc-images/bootiso/install.iso microshift-bootc-embeeded-4.19.iso
fi
----
====

. Build the 4.19 appliance (~10–15 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build.sh 4.19 2>&1 | tee build-4.19.log
----

[#validation]
== 2.5 Validation: Success Criteria

[cols="1,3", options="header"]
|===
| Component | Expected Status
| **Base Image** | `microshift-bootc:base` exists in podman.
| **Appliance Image** | `microshift-bootc-embeeded:4.19` exists in podman.
| **Bootable ISO** | `microshift-bootc-embeeded-4.19.iso` is created and >5GB.
|===

[source,sh,role=execute]
----
sudo podman images | grep microshift-bootc
ls -lh microshift-bootc-embeeded-4.19.iso
----

---
**Next:** Proceed to xref:module-03.adoc[Module 3: Deploying to Edge Locations].
