= Module 1: Foundation: Environment Setup & Image Mode Foundations

[#setup]
== 1.1 Lab overview: Environment and components

Similarly as on link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 - Unleashing The Power of Image Mode for RHEL] lab, you will interact with a total of 3 systems: the primary lab hypervisor, a container registry, and an image mode VM.  Most of your work will be done on the lab hypervisor, and you will create the target image mode VM as part of the exercises. Caution should be taken when instructed to reboot a system that you are on the correct host.

[NOTE]
The entire lab environment is already prepared for you. Your build host has the required tools installed, MicroShift bundles are available, and the sample application content is included in the lab repository.

== Lab diagram

image::lab-diagram.png[]

== System purpose

*Container build host*: One of the main parts of this lab is the build environment. The primary lab machine serves as a basic container build environment. The RHEL container tools (podman, buildah, skopeo) will be used throughout this lab to do simple container creation. This is all that is needed for a basic build host. You will also create the Containerfiles and any other needed configuration files on this host.

*Container registry*: The registry in this lab environment is a basic registry with no authentication or management tooling. More tools, workflows, and insights are available from more modern registry solutions like quay.io. For the purposes of the exercises, a simple registry to host images is all that's needed. You will be using it for build your images and updating your target system in one of the use cases (i.e. connected, connected on-demand). 

Although we do have a registry in this lab, we do also intend to simulate a disconnected deployment, where the ISO is used for installing the appliance and must be self-contained. Later in the lab, we will also attempt a disconnected update as well. 

image::disconnected.jpg[disconnected-workflow,100%,100%]

*Target host*: A KVM based virtual machine will be created during an exercise to serve as an install location for the image mode system. Any cloud, virtual, or bare metal machine can be used in practice. This lab won't go into detail on local management of KVM, but will use virt-install and virsh to manage the local VM.


[#edge_challenge]
== 1.2 The Edge Challenge & The RHEL Image Mode Solution
Edge systems often run in tough, inconsistent environments. Common challenges include:

* *Configuration Drift:* Systems slowly diverge from their intended state.
* *Risky Updates:* Traditional update methods can break systems in the field.
* *Disconnected Locations:* Many devices have intermittent or no network connectivity.

RHEL Image Mode addresses these challenges by treating the *entire* OS as an immutable, versioned image.  
Instead of updating individual packages, you deploy a new OS image exactly like updating a container.

[#bootc]
== 1.3 Introducing RHEL Image Mode (bootc)
RHEL Image Mode, backed by **bootc**, replaces traditional package-based management with an “image-first” workflow.

Key benefits:
* **Atomic updates:** The whole system updates in one operation.
* **Rollback safety:** A previous working version is always available.
* **Consistency:** Every device boots from the same known-good image.
* **Simplicity:** Build, ship, and manage appliances like container images.

This model is ideal for appliances, remote edge clusters, industrial gateways, and environments where reliability outweighs customization.

[#workflow]
== 1.4 The Build-Deploy-Manage Workflow
A typical Image Mode workflow looks like this:

. Define your OS + application layers inside a `Containerfile`.
. Build a bootable container image from that specification.
. Generate an ISO or disk image from the container image.
. Deploy the image to target edge systems or VMs.
. Manage updates by shipping new container image versions.

[NOTE]
In this lab, the application (WordPress + MySQL) and MicroShift components are already provided. You will see how they can all be included directly inside the OS image.

[#setup]
== 1.5 Hands-On: Environment Setup
Your environment includes:
* A **build host** (where you run all commands).
* A **prepared folder structure** with `Containerfile` examples and helper scripts.
* A **sample workload** (WordPress) ready to be deployed on MicroShift.
* A **target VM** that will be created later to boot your generated appliance image.

To begin, clone the lab repository that contains all the files you will work with:

. Clone the lab repository:
+
[source,sh,role=execute]
----
git clone https://github.com/redhat-gpte-devops-enablement/bootc-embedded-containers.git
----

. Change into the repository directory:
+
[source,sh,role=execute]
----
cd bootc-embedded-containers
----

[NOTE]
No additional configuration is required. All needed tools, container runtime settings, and supporting files are already present in the lab environment.

---

Next: proceed to xref:module-02.adoc[Module 2: Building the Base Image].
